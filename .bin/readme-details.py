#!/usr/bin/env python

##   readme-details.py  ---  Scrapes preamble descriptions from files.

# Copyright (c) 2023   Julian Orchard <jorchard@pm.me>

## Description:

# This is the script that generates what you might be reading *now*!

# It scrapes the `.bin/` folder and gets the text under the 'description'
# heading (above). It's pretty simple, but nice to give an overview of
# what files are in this repo.

## License:

# See /LICENSE file in the root of this repository.

## Code:

from pathlib import Path
import os
import re

HOME_PATH = str(Path.home())
README_FILE = f"{HOME_PATH}/README.md"
BIN_PATH = f"{HOME_PATH}/.bin/"
README_PREAMBLE = """
# Dotfiles and Configurations

> These are my `dotfiles`. There are many like them, but these ones are mine.
>
> My `dotfiles` are my best friends. They are my life. I must master them as I master my life.
>
> My `dotfiles`, without me, are useless. Without my `dotfiles`, I am useless.

They're mainly used on Windows, Ubuntu, and occasionally with Arch. They mainly contain scripts for said systems, as well as Emacs, Vim, and VS Code configurations.

## History

I started my journey storing these files with a bare git repo (following steps [here](https://www.atlassian.com/git/tutorials/dotfiles)). I then moved to a [literate configuration](https://en.wikipedia.org/wiki/Literate_programming), using Emacs [Org Mode](https://orgmode.org/). Finally, I've moved *back to using a bare repo*.

Why did I change this? Using a literate configuration made everything reproducible, easy to manage, and thoroughly documented!

The main reason is because I realised I was getting *slightly* too stuck into Emacs, and I still enjoy using Vim and have even started using VS Code (with the Vim plugin installed, of course). It also didn't work well on remote servers, as I'm not a fan of terminal Emacs.

Using a literate configuration made it feel like I was working on a large text document rather than directly with a computer. I found I stopped writing as much code and started using Org to manage tasks and things more. This was good, but I want to do programming and scripting. I stopped writing scripts (in anything by Elisp) which improved my workflow.

So I'm back to doing it like this, and I'm happy with that to be honest.

## Deploy

I use a [bare git repo](https://www.atlassian.com/git/tutorials/dotfiles) to manage these files, as I think it's one of the most system-agnostic methods. It does mean you need Cygwin or Git Bash on Windows (I mainly use the latter).

You can execute a command like this to install the dotfiles from a remote source:

```sh
<<<<<<< HEAD
$ curl -Lks https://julianorchard.co.uk/bin/install.sh
=======
$ curl -Lks https://julianorchard.co.uk/bin/install.sh | /bin/bash
>>>>>>> 4dcd7dec95ed65432cc4da23630df75420024ee7
```

## Featured Scripts

The below is generated by `.bin/readme-details.py`!

"""
README_POSTAMBLE = """
## Contributing

These are my personal dotfiles. If you want to fork this repo and use them, that's absolutely fine, but (unless you find a breaking change) I probably won't be accepting PRs.

## License

Everything here, unless otherwise stated[^1], is under the MIT License. See [License](/LICENSE) for more information.

[^1]: Emacs typically uses GPLv3+, but this is compatible with the MIT license. Chocolatey is under the Apache 2.0 license, so again, compatible.

## Credits

These credits don't cover every resource that has helped me on my way to these configurations, but they're hopefully giving credit to some of the biggest influences on them...

#### Emacs

- [Daviwil's literate dotfiles](https://github.com/daviwil/dotfiles) and [his Emacs From Scratch series](https://github.com/daviwil/emacs-from-scratch) (which is what got me into Emacs in the first place!)
- [Tecosaur's config](https://tecosaur.github.io/emacs-config/config.html); *the most beautiful literate configuration I've ever seen* - Even though I don't use it direcitly, [Doom Emacs](https://github.com/doomemacs/doomemacs) has been a massive help
- [RedGuardToo's](https://github.com/redguardtoo/emacs.d) dotfiles, plus his [Mastering Emacs in One Year](https://github.com/redguardtoo/mastering-emacs-in-one-year-guide) Guide
- [MatthewZMD's M-Emacs](https://github.com/MatthewZMD/.emacs.d)
- [Protesilaos'](https://protesilaos.com/emacs/dotemacs) great Emacs tips, packages (especially themes), and [YouTube videos](https://www.youtube.com/@protesilaos)

#### Vim

- [Tim Pope](https://github.com/tpope), for obvious reasons
- The dotfiles of [Daniel Hahler](https://github.com/blueyed)

#### Windows

- [Chocolatey](https://chocolatey.org/) for their very useful [`refresh.cmd`](https://github.com/chocolatey/choco/blob/develop/src/chocolatey.resources/redirects/RefreshEnv.cmd)
"""

def print_without_comments(line):
    '''
    Simply removes comments from the start of the lines in a
    very simple manner.

    Would be nice to be able to use a case statement...
    '''
    if "# " in line:
        line = line[2:]
    if ":: " in line:
        line = line[3:]
    if "' " in line: # TODO: this would also remove ending apostophes' (like this)
        line = line[2:]

    return line.replace("\n", " ").replace("\t", " ")

def main():

    # Start of the file, title, etc.
    output = README_PREAMBLE

    for file in os.listdir(os.fsencode(BIN_PATH)):
        filename = os.fsdecode(file)

        current_file = open(f"{BIN_PATH}{filename}", 'r')
        lines = current_file.readlines()

        description_active = False

        for line in lines:
            if " Description:" in line:

                # Title of the file we're getting the details of:
                output = f"{output}#### `{filename}`:\n\n"
                description_active = True
            elif description_active == True  \
                and " License:"      in line \
                 or " Code:"         in line \
                 or " Instructions:" in line:

                # We're no longer dealing with the description:
                description_active = "False"
                output = f"{output}\n\n"
                break
            elif description_active == True and line != "\n":

                # Output the line without the comment, ideally:
                output = f"{output}{print_without_comments(line)}"

    # Finish the file off!
    output = f"{output}{README_POSTAMBLE}"

    # Write to the file
    out_file = open(README_FILE, "w")

    # Regex replace if more than three line breaks + multiple spaces
    out_file.write(re.sub("[\r\n]{3,}|[\s]{2,}", "\n\n", output))
    out_file.close

if __name__ == '__main__':
    main()
